전체 테스트 케이스: 50개, C/C++ 1초, JAVA 1.5초 / 메모리 제한: 256MB, Stack: 1MB

1부터 N까지의 자연수를 원 모양으로 배열했을 때 연속된 두 수의 합이 항상 어떤 정수의 제곱이 되면 이 배열을 완전 제곱 고리(perfect square circle)라 부른다. 아래 <그림 1>은 N=32N=32N=32인 완전 제곱 고리의 한 예시이다. 그리고 놀랍게도 어떤 프로그래머가 NNN이 25 이상 1,048,576 이하일 때 완전 제곱 고리가 존재함을 보였다.

<img width="484" alt="image" src="https://user-images.githubusercontent.com/68772751/208238728-c2926426-4839-45ea-a9bf-60fd491dff1e.png">
<그림 1>

사실, 1부터 N까지 배열하는 모든 수의 경우의 수를 고려하여 완전 제곱 고리를 찾는 것은 매우 힘든 일이다. 고작 NNN이 13만 돼도 고려해야 하는 연산의 횟수가 60억이 넘는다.

그런데 완전 제곱 고리를 본 헤인즈는 서로 다른 NNN개의 자연수를 원 모양으로 배열했을 때 연속된 두 수의 합 중 제곱수가 가장 많이 나오는 경우를 알고 싶어졌다. 그리고 헤인즈는 이 경우를 거의 제곱 고리라고 부르기로 했다.

<img width="529" alt="image" src="https://user-images.githubusercontent.com/68772751/208238746-80cb25c9-9e01-4501-840e-967901c6ffb6.png">

<그림 2>는 1, 3, 6, 8이 주어졌을 때 원 모양으로 배열하는 모든 경우의 수이다. 거의 제곱 고리는 2 종류가 있으며 이 때 연속된 두 수의 합이 제곱이 되는 경우는 최대 3번이며, 빨간색 박스에 들어 있는 경우가 거의 제곱 고리이다.

서로 다른 N개의 자연수가 주어졌을 때 거의 제곱 고리에 존재하는 연속된 두 수의 합이 제곱수가 되는 개수를 구하여라.

[제한 사항]
서로 다른 숫자의 개수 N은 4 이상 10 이하이다.
주어지는 서로 다른 숫자는 1000 이하이다.
[입력]
맨 처음 테스트 케이스의 개수 T가 주어지며 그 다음 T개의 테스트 케이스가 주어진다. 각 테스트 케이스는 두 줄로 이루어져있다.
첫 번째 줄에는 서로 다른 숫자의 개수 N이 주어진다. 두 번째 줄에는 서로 다른 자연수 N개가 공백으로 구분되어 주어진다.

[출력]
테스트 케이스 하나 당 한 줄씩 출력한다.
맨 처음 #x (x 는 테스트케이스 번호, 1부터 시작)을 출력하고 공백을 하나 둔 후, 거의 제곱 고리에 존재하는 연속된 두 수의 합이 제곱수가 되는 횟수를 출력한다.
